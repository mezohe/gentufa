// This is a Parsing Expression Grammar for Gua\spi
// See http://bford.info/packrat/
// 
// All rules have the form:
// 
// 	name = peg_expression
// 
// which means that the grammatical construct "name" is parsed using
// "peg_expression".  
// 
// 1)  Names in lower case are grammatical constructs.
// 2)  Names in UPPER CASE are selma'o (lexeme) names, and are terminals.
// 3)  Concatenation is expressed by juxtaposition with no operator symbol.
// 4)  / represents *ORDERED* alternation (choice).  If the first
//     option succeeds, the others will never be checked.
// 5)  ? indicates that the element to the left is optional.
// 6)  * represents optional repetition of the construct to the left.
// 7)  + represents one_or_more repetition of the construct to the left.
// 8)  () serves to indicate the grouping of the other operators.
//
// Longest match wins.

// ___ GRAMMAR ___

{
  
  // === ZOI functions === //

  function _zoi_assign_delim(word) {
	var a = word.toString().split(",");
	if (a.length > 0) _g_zoi_delim = a[a.length - 1];
	else _g_zoi_delim = "";
	return word;
  }

  function _zoi_check_quote(word) {
	if (typeof(word) == "object") word = word.toString();
    if (!is_string(word)) {
	  alert("ZOI word is not a string");
	  return false;
	} else {
      return (word.replace(/,/gm,"") === _g_zoi_delim);
	}
  }
  
  function _zoi_check_delim(word) {
	if (typeof(word) == "object") word = word.toString();
    if (!is_string(word)) {
	  alert("ZOI word is not a string");
	  return false;
	} else {
	  word = word.split(",");
	  if (word.length > 0) word = word[word.length - 1];
	  else word = "";
      return (word === _g_zoi_delim);
	}
  }
  
  function is_string(v) {
    return typeof v.valueOf() === 'string';
  }
  
  function _concat(a, b) { return a && a.concat(b) }
  function arrayifnot(a) { return Array.isArray(a) ? a : [a] }
  function truthy(val) {
    return val;
  }
  function join(array) {
    if (!Array.isArray(array)) return array;
    return array.filter(truthy).map(join).join("");
  }
  function subord_hack(down, terms) {
    if (down == "|") terms[0].predicate.unshift("|");
    return terms;
  }
}

text = first:sentence rest:(&start s:sentence { return s })* { return [first].concat(rest) }

sentence = 
start:start?
terms_begin:(
	terms_begin_repeat:terms_top*
	{ return terms_begin_repeat.reduce(_concat, []) }
)
propo_tail:(
	(fi0 compound)? 
	predicate:predicate 
	terms_end:(
		terms_end_repeat:terms_top*
		{ return terms_end_repeat.reduce(_concat, []) }
	)
	{ return {predicate:predicate, terms_end:terms_end} }
)?
{
	var r = {predicate: "_", terms: terms_begin || []};
	if (propo_tail) {
		r.predicate = propo_tail.predicate;
		if (propo_tail.terms_end) 
			r.terms = r.terms.concat(propo_tail.terms_end);
	}
	return r;
}
/ prefix:(compound_je prefix)+ sent:sentence {
  if (prefix.length)
    sent.predicate[0] = "-" + sent.predicate[0];
  sent.predicate = prefix.map(function (a, i) { return (i ? "-" : "") + a[1] }).concat(a);
  return sent;
}

start = a:same b:I { return a + b }

terms = d:down a:term+ endphrase { return subord_hack(d, a) }

terms_top = fi0? d:down a:((fi1 (compound !same)?)? b:term_top { return b })+ endphrase { return subord_hack(d, a) }

term = same? prefix:(compound_je prefix)* pre_terms:terms? a:predicate b:terms? {
  var terms = []; 
  if (pre_terms)
    terms = terms.concat(pre_terms);
  if (prefix.length)
    a[0] = "-" + a[0];
  a = prefix.map(function (a, i) { return (i ? "-" : "") + a[1] }).concat(a);
  if (b) terms = terms.concat(b);
  return terms.length && {predicate: a, terms: terms} || {predicate: a};
}

term_top = (fi2 compound)? t:term { return t }

predicate = compound_je a:brivla b:(c:compound d:brivla { return c ? c+d : d })* { return [a].concat(b) }


word = magic / prefix / brivla

brivla = !magic 
// !prefix
a:(consonant+ / "" { return [] }) b:vowel+ space* { return a.join("") + b.join("") }

prefix = !magic a:( "f" [aeilnoruy] / "qo" // /"z" [aeilmoruy] 
/ "s" [aeioru] // / "fw" 
/ "v" [aeiou] // / "qu" 
/ "v" [ylrn] / "x" [aeinoruwy] / "b" [inu] / "q" [aeilry]) !vowel space* { return join(a) }

magic = I / fi

consonant = [:bcdfgjkpqstvxz]

vowel = [aeiouyrmnlw]

space = " "


I = ":"? a:[aeiou] !vowel space* { return ":" + a }

fi = fi0 / fi2 / fi1

fi0 = up "fi" !vowel space* { return "/fi" }

fi1 = compound_je "fi" !vowel space* { return "-fi" }

fi2 = down "fi" !vowel space* { return "\\fi" }


tone = up / down / same / compound

tonechar = [/\\!^|=\-]

endphrase = &start / (!word (up / same)?) / &fi

up = "/" !tonechar { return "/" }

down = down_1 / subordinate

compound = compound_be / compound_je

same = "^" !tonechar { return "^" }

down_1 = [\\!] !tonechar { return "\\" }

subordinate = "|" !tonechar { return "|" }

compound_be = "=" !tonechar { return "=" }

compound_je = "-"? !tonechar { return "-" }
